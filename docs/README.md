> # 00回顾
>
> - 建议多留一些编程题，提升逻辑思维能力：
>
> 
>
> - 字面量：首先我们能从字面上写的数据，就知道它是什么类型；
>
> ```
> var a = "abc";
> var b = 1;
> var arr = [];
> var arr = new Array();
> ```
>
> - 为什么对象math和date的调用方式不一样，date需要创建一个新的对象，而math不用？
> - new Date(); 生成一个对象后，实例化；
> - 回顾：数组
>   - 顺序，有长度的数据集合；
>   - 遍历：循环，index 最后的索引值index = arr.length-1;
>
> 
>
> # 01-函数-介绍-语法-调用
>
> - 语法：
>
> ```js
> // 声明函数：
> // function :关键字 
> // tell_story：函数名
> function tell_story(param) {
>  // 函数体；
>  console.log("山上有庙");
>  console.log("庙有和尚");
>  console.log("和尚说事");
>  console.log("老和尚对小和尚：");
> }
> 
> // 调用执行：函数名后面跟着一个(),表示会执行前面声明好的函数；
> tell_story();
> ```
>
> 
>
> # 02-函数-参数-配置
>
> - 语法：把你要抽象的数据配置为参数，记得要放入声明函数时，后面的（）
>
> ```js
> // 函数声明，配置两个参数：
> function tell_story(name_1, name_2) {
>  // 函数体；
>  console.log("山上有庙");
>  console.log("庙有和尚");
>  console.log(name_1 + "说事");
>  console.log(name_1 + "对" + name_2 + "说：");
> }
> 
> 
> 
> // 调用函数
> tell_story("铁头", "熊大");
> 
> 
> // 如何去配置参数：
> // 根据你的业务需求，把一些你要抽象的数据，配置为参数。
> // 记得：在函数的()内，写上你配置的变量名；
> // 在声明函数的，内部的变量才算是声明了。
> ```
>
> 
>
> # 03-函数-参数-不赋值
>
> - 语法
>
> ```js
> // 函数声明，配置两个参数：
> function tell_story(name_1, name_2) {
>  // 函数更严谨的写法；
>  // 判断一下name_1, name_2是否为undefined;
>  // if (name_1 == undefined) {
>  //   name_1 = "大哥";
>  // }
> 
>  // 配置对参数的默认值；
>  // if (name_2 == undefined) {
>  //   name_2 = "二哥";
>  // }
> 
>  // 三元表达式；
>  // 表达式1?表达式2:表达式3;
>  // name_1 = name_1 == undefined ? "大哥" : name_1;
>  name_1 = name_1 ? name_1 : "大哥";
> 
>  // name_1没有传值 undefined
>  // undefined ？name_1："大哥";
>  // false ？name_1："大哥";
> 
>  // name_1 传入值 "张三"
>  // "张三" ？name_1："大哥";
>  // true?name_1："大哥";
>    
>  // 严谨写法：三元表达式；
>  name_2 = name_2 ? name_2 : "二哥";
> 
> 
>  // 函数体；
>  console.log("山上有庙");
>  console.log("庙有" + name_1 + "," + name_2);
>  console.log(name_1 + "说事");
>  console.log(name_1 + "对" + name_2 + "说：");
> }
> ```
>
> 
>
> # 04-函数-参数-形参与实参
>
> - 形参：形式上先参与函数内部逻辑的一些参数，没有调用时，不知道要传入什么；
> - 实参：真实传入数据，可以直接传数据，也可以传入外面已经定义好的变量；
> - 形参与实参：要传入的数据是**简单数据类型**数据，形参与实参相互不影响；
>
> ```js
> // 声明函数，没有执行；
> function demo(x, y) {
>  x = x + y;
>  console.log(x, y);
> }
> 
> // 调用时，函数执行
> var a = 10;
> var b = 20;
> 
> // a/b 背后代表的值传入了！！！
> demo(a, b);
> 
> // a，b 把值传入，传入后，和a,b没有任何关系；
> console.log(a, b);
> ```
>
> 
>
> # 05-函数-返回值
>
> - 语法：
>
> ```js
> // 定义函数：参数，可以在内部参与运算
> // function qiu_he(x, y) {
> //   var sum = x + y;
> //   // console.log(sum);
> 
> //   // return:作用1：返回值，必须后面跟一个值；即将要作为函数执行完后，返回的值；
> //   return sum;
> // }
> 
> // 调用函数：传入实参
> // 想要获取到结果 
> // var sum = qiu_he(12, 12);
> // // 默认返回是undefined；
> // console.log(sum, '外面的函数返回值');
> 
> 
> // 作用2：终止函数的执行
> function demo() {
>  console.log("1111111111111");
>  console.log("2222222222222");
>  // 终止函数的执行,函数内部下面的代码不执行了
>  return;
>  console.log("3333333333333");
> }
> var res = demo();
> // 看下：return后面没有值的时候，返回的是啥？
> console.log(res); // 返回undefined
> ```
>
> 
>
> # 06-函数-案例-求n-m和
>
> - 语法：
>
> ```js
> // n-m数字的和;
> // 注意：
> // 比如：n>m
> // 比如：
> // 封装函数：
> function get_sum_2(n, m) {
>  // 
> 
>  // 内部定义的变量
>  var sum = 0;
>  for (var index = n; index <= m; index++) {
>    sum += index;
>  }
>  // console.log(sum);
>  return sum;
> }
> 
> // 会接受到函数的返回值；
> var res = get_sum_2(5, 6);
> console.log(res);
> ```
>
> 
>
> 
>
> # 07-函数-参数-arguments
>
> - 语法：可以获取所有传入函数的实参，形成一个伪数组；本质是个对象，可以循环遍历；
>
> ```JS
> function fn() {
>  // arguments:函数内部的变量，
>  // 不需要我们声明的；
>  // console.log(arguments);
> 
>  // 伪数组：但是可以循环遍历的。
>  for (var index = 0; index < arguments.length; index++) {
>    console.log(arguments[index]);
>  }
> }
> ```
>
> 
>
> # 08-函数-函数表达式-匿名函数
>
> - 匿名函数：JS内不允许匿名函数单独存在；
>
> ```js
> // 函数表达式:声明函数的另外一种方式
> // get_sum：变量名；
> // 变量：储存的是函数，变量名就是以后的函数名；
> // var get_sum = function(a, b) {
> //   return a + b;
> // };
> 
> // 返回结果
> // var res = get_sum(1, 2);
> // console.log(res);
> 
> 
> // 匿名函数；JS不允许匿名函数单独出现，需要配合其他语法进行使用；
> //
> // function() {}  
> 
> 
> // 自执行函数：页面打开自己就执行；
> // function fn() {}
> // fn();
> (function() {
>  // 
>  console.log(1);
> 
> })();
> ```
>
> 
>
> # 09-函数-函数类型-回调函数
>
> - 语法：
>
> ```js
> // 变量背后代表的是一个函数；
> // var fn = function() {
> //   console.log(1);
> // };
> 
> // 函数类型；返回function类型
> // console.log(typeof fn);
> 
> 
> // 回调函数：
> function demo_1(a, fn) {
>  a = a + 1;
> 
>  // 形参:需要传入一个函数；
>  fn();
> }
> 
> // 声明个函数；
> var demo_2 = function() {
>  console.log(1);
> }
> 
> // 当我们实参是有函数，传入，这个函数叫回调函数；
> demo_1(10, demo_2);
> 
> // 参数有函数传入，这个就叫回调函数；
> demo_1(20, function() {
>  console.log("我是匿名函数，作为参数进行传入");
> })
> ```
>
> 
>
> # 10-js-作用域
>
> - 全局作用域：
>
> ```JS
> // 全局作用域
> // 全局变量：在你声明的这个作用域内，任何地方都可以访问；
> // var a = 10;
> 
> // function demo() {
> //   console.log(a);
> // }
> 
> // demo();
> ```
>
> - 局部作用域：
>
> ```js
> // 局部作用域：声明的函数内部的范围；
> // function demo() {
> //   // 局部变量：只能在你的局部作用域访问；
> //   var b = 20;
> // }
> 
> // // 外面访问不到局部作用域内的变量；
> // console.log(b);
> ```
>
> 
>
> # 11-js-预解析
>
> - 预解析，也叫变量提升：会把声明的变量和函数提升到你当前的作用域的最顶端；
> - 注意：你当前的作用域的是在哪？
>   - 是全局作用局
>   - 还是局部左右域；
> - 基础面试题：
>
> ```js
> // 观察下面的代码，说出执行结果
> var num = 10;
> fun();
> 
> function fun() {
> console.log(num);
> var num = 20;
> }
> 
> 
> // ------------------------------------------------------------变量提升的演示
> // 预解析：先把你声明变量、函数先全部提升到你当前的作用域的最顶端；
> var num;
> 
> function fun() {
>  var num;
>  console.log(num);
>  num = 20;
> }
> 
> // 赋值；
> num = 10;
> // 函数调用；
> fun(); // 输出 undefined；
> ```
>
> 
>
> # 12-小娜v2-函数封装
>
> 
>
> # 13-总结
>
> - 参数：
>   - 形参：形式上参与函数内部逻辑的那个参数
>   - 实参：实际参与的运算的数据；
> - 返回值：设置return 数据；
> - arguments：
>   - 函数内部变量
>   - 获取所有传入的实参；
>   - 伪数组：可以遍历；
> - 作用域与预解析：把我们的声明的变量和声明的函数提升到  **当前作用域顶部**；
> - 当前作用域：局部作用域还是全局作用域；
>
> ```
> function fn(){}
> 
> // 提升的只是 var fn；
> var fn = function(){}
> ```
>
> 
>
> 
>
> # js基础-day-03
>
> # 数组
>
> - 一个人的成绩可以用一个变量存储，500个人的成绩，我们就不用500个变量存储了，我们可以使用数组存储。
>
> ## 介绍
>
> - 数组是一个有**顺序**、**有长度**的数据集合；
> - 数组：类型Object；
> - 特点：
>   - 把数据放在一起；
>   - 有先后位置上的顺序；
>   - 有数据的长度；
>
> ## 声明
>
> ```javascript
> // 5个人的成绩为： 91，88，72，45，63
> // 先声明一个数组，字面量的形式
> var arr = [];
> 
> // 输出 []  这是一个没有数据在里面的数组，称为空数组
> console.log(arr,typeof arr); 
> ```
>
> ## 存值
>
> - 数组中的数据使用**索引**管理。
> - 索引：**序号、顺序、排位、位置、下标**
> - **索引从0开始**
>
> ```javascript
> //把成绩存储到数组中
> arr[0] = 91;
> arr[1] = 88;
> arr[2] = 72;
> arr[3] = 45;
> arr[4] = 63;
> console.log(arr); // 输出 [91,88,72,45,63] 就是一个数据集合
> ```
>
> - 把 `数组[索引]`格式当成一个变量使用就行，
>
> ```js
> // 初始化赋值完成后，也可以再次改变值，把前面的值覆盖掉；
> arr[0] = 100;
> ```
>
> - 如果一开始就知道数组了，可以直接使用一个简单的语法存储数据
>
> ```javascript
> var arr = [91,88,72,45,63];
> console.log(arr); // 输出的结果是一样的
> ```
>
> - 上面每个位置上存的都是数字类型，可以为其他类型；
>
> 
>
> 
>
> ## 取值
>
> - 把数据取出来，得知道你要取哪个位置上的数据把。
> - 数据取值同样使用**索引**取。
>
> ```javascript
> // 拿到索引为0，顺序上第一个位置上的数据；
> // 把 数组[索引] 格式当成一个变量使用就行；
> console.log(arr[0]);
> 
> // 数组求和：班里的成绩总和
> var sum = arr[0] + arr[1] + arr[2] + arr[3] + arr[4];
> console.log(sum); // 输出370
> ```
>
> 
>
> ## 遍历
>
> - 求成绩总和：一个一个地把数组里面的数组取出来了，从索引 0 到最后一个索引，
> - 索引从0开始到结束的过程，**有重复的思想，需要用到循环；**
>
> ```javascript
> // 最初的写法
> var sum = arr[0] + arr[1] + arr[2] + arr[3] + arr[4];
> 
> 
> // 循环 这个从0~最后一个索引，有重复的思想在里面，使用循环。
> var sum = 0;
> for(var i = 0; i <= 4; i++){
>   sum += arr[i];
> }
> console.log(sum); // 输出 370，和我们一个一个相加是一样的
> ```
>
> - 使用**循环来遍历**数组，当数组中的数据比较多的时候，会比较方便。**一般是使用for循环；**
>
> 
>
> ## 数组长度
>
> ### 语法
>
> - 存取数据：涉及到就是数组的**顺序**问题，通过索引去存取；
> - 数组长度：数组中一共存放了多少个数据；
>
> ```javascript
> console.log(arr.length); // 数组.length 就是数组的长度
> ```
>
> - 如果数组的长度是5，最后一个元素的**索引**就是4；
> - **我们发现最大索引总是比长度少 1 ，所以遍历还可以这么写**
>
> ```javascript
> for(var i = 0; i <= arr.length - 1; i++){
>   console.log(arr[i]);
> }
> 
> // 简化一下 
> for(var i = 0; i < arr.length; i++){
>   console.log(arr[i]);
> }
> ```
>
> ### 案例：求数组中所有数字的总和的平均值
>
> - 分析：
>   - 总和：循环遍历，加在一个变量上得到；
>   - 均值：总和 / 个数；（arr.length）
>
> ```js
> // 还可以更简单
> var sum = 0;
> for(var i =0; i < arr.length; i++){
>   sum += arr[i];
> }
> console.log(sum);
> 
> // 求平均分
> // 平均分= 总分 / 数组的长度
> var avg = sum / arr.length;
> 
> ```
>
> ### 案例：求数组中的最大值
>
> - 分析：生活中，一堆人最高的（人很多，多到你一下看不出来）；
>   - 最大值：最起码得两个数比较下，得到最大值；
>   - 假设：其中随便一个是最大值MAX，每个元素和max比较，
>     - 若有比MAX大的，那该元素代替MAX；
>     - 若都没有MAX大，恭喜，你一开始就猜对了；
>
> ```js
> var max = arr[0];
> for(var i =0; i < arr.length; i++){
>   if(max < arr[i]){
>     max = arr[i];
>   }
> }
> 
> ```
>
> - 需求：求数组中的最大值的索引
>
> ```js
> // 分析：找打最大值的时候，记录下最大值的下标就行了。
> var max_index = 0;
> var max = arr[max_index];
> for(var i =0; i < arr.length; i++){
>   if(max < arr[i]){
>     max = arr[i];
>     max_index = i;
>   }
> }
> 
> ```
>
> ### 清空数组
>
> ```js
> arr.length = 0;
> 
> ```
>
> 
>
> 
>
> 
>
> ## 数组的构造函数
>
> - 数组在JS中还可以使用另一种方式创建，这个方式我们称为 ： 构造函数
> - 构造函数：能构造一个你需要的东西（对象）；
>
> ```javascript
> // 使用 构造函数 创建数组
> var arr = new Array();
> // 存储数据
> arr[0] = 10;
> arr[1] = 20;
> console.log(arr);
> 
> var arr = new Array(10,20);
> console.log(arr);
> 
> ```
>
> - 注意：一个数据，不要使用这个方式存储数据；它会认为你想要设置数组的长度，而不是要把数据存储在数组中。
>
> ```javascript
> var arr = new Array(10);
> console.log(arr); // 输出 [empty × 10]
> 
> ```
>
> 
>
> 
>
> # 小娜V1.0
>
> ## 需求
>
> - 输入q：完全退出；
> - 输入1：得到求和功能，我们输入"数字,数字,数字"的格式，帮我们计算出我们的输入的和；
> - 输入2：获得当前时间；
> - 输入3：随机给我讲一个笑话；
> - 不q：一直循环 提示 可以 输入1/2/3、q这些功能点；
>
> ## 功能
>
> ### 循环与退出
>
> - 使用wihle，设置条件为true，一直循环；
>
> ```js
> while(true){
>     
> }
> 
> ```
>
> - 在内部使用变量接受用户输入的信息，使用固定值switch case 判断用户输入的是哪种情况
>
> ```js
> while(true){
>   var result = prompt('你好，我是小娜，请输入下面的数字，决定你要干什么。\n1-计算综合，\n2-获取时间,\n3-讲个笑话');  
>   switch (result) {
>     case 'q':
>       
>       break;
>   }
> }
> 
> ```
>
> - 退出功能：使用break退出while，
>
> ```js
> while(true){
>   var result = prompt('你好，我是小娜，请输入下面的数字，决定你要干什么。\n1-计算综合，\n2-获取时间,\n3-讲个笑话');  
>   switch (result) {
>     case 'q':
>       // 如果在这里写break，会被认为是switch case 的break,所以该处不能这样使用，应该在外面使用if进行判断；
>       break;
>       break;
>   }
>   
>   if(result=='q'){
>   	  alert('你不爱小娜了吗');
>       break;
>   }
> }
> 
> ```
>
> ### 求和
>
> - 需求：输入1，进入求和功能
>
> ```js
> // 注意： 输入的都是字符串，所以这里要使用字符串比较
> case '1':
> 	var nums = prompt('请输入要求和的数字，以逗号隔开，例如： 1,2,3,4');
> 
> break;
> 
> ```
>
> - 需求：我们输入"数字,数字,数字"的格式，需要转为数组，求和；
>
> ```js
> var str = '12,88,72,6';
> // 以逗号为分隔符，分割字符串，得到一个数组
> // 字符串.split(指定分隔符)
> // 后面的指定分隔符就是我们写字符串数字与字符串数字之间的间隔符号
> var arr = str.split(',');
> 
> // 输出 ['12','88','72','6']
> // 转为数组，但不是说里面的元素转为数字类型了；
> console.log(arr); 
> 
> ```
>
> - 求和：循环、每个元素转类型；
>
> ```js
> sum += parseFloat(arr[i]);
> 
> ```
>
> ### 获取时间
>
> - 需求：输入2，获取当前时间；
> - 在js中，要获取系统的当前日期和时间，需要用到一个js自带的**Date对象** ，
> - **现在先不用管什么是对象，先学习如何使用，对象能给我们带来什么**
>
> ```js
> // 创建Date对象
> var date = new Date();
> console.log(data); // 系统时间不同，输出的结果也会不同，但是都是输出当前系统的时间
> 
> // 获取时间对象的各个部分，对象.方法();
> 
> // 获取年份
> var year = date.getFullYear();
> console.log(year);
> 
> // 获取月份 ， 得到的月份是从0开始的 ，使用 0-11 表示 1-12 月
> var month = date.getMonth();
> console.log(month);
> 
> // 获取天
> var day = date.getDate();
> console.log(day);
> 
> // 获取小时
> var hour = date.getHours();
> console.log(hour);
> 
> // 获取分钟
> var minute = date.getMinutes();
> console.log(minute);
> 
> // 获取秒数
> var second = date.getSeconds();
> console.log(second);
> 
> ```
>
> - 为了格式上的好看：单位数，补位成双位数；
>
> ```js
> if(day < 10){
>     day = '0' + day;
> }
> 
> ```
>
> 
>
> ### 随机笑话
>
> - 需求：输入3，随机给我讲个笑话；
> - 随机值：每次给你的值，一般情况下是不一样的。
> - 有给随机值的一个对象Math；
>
> ```js
> // 获取随机数
> var r = Math.random();
> 
> // 输出一个在 [0,1) 之间的浮点数，可以得到0，但是无法得到1
> console.log(r); 
> 
> ```
>
> - 如果想要得到一个随机整数，需要把整机浮点数  乘以 一个 倍数，再取整，
>
> ```js
> // 获取 [0,10) 之间的随机浮点数，随机的一个值，
> var r = Math.random() * 10;
> 
> ```
>
> - 取整：向下取整，向数轴的左边获取最近的一个整数
>
> ```js
> // 向下取整
> var a = Math.floor(1.12);
> console.log(a); // 输出1
> var b = Math.floor(1.99);
> console.log(b); // 输出1
> var c = Math.floor(-3.2);
> console.log(c); // 输出 -4
> var d = Math.floor(3.9);
> console.log(d); // 输出 -4
> 
> ```
>
> - 获取一个随机整数
>
> ```js
> // 获取一个 [0,10] 之间的随机整数
> var r = Math.random();
> r = r * (10 + 1) ;// 因为 Math.random得到的是不能得到1的浮点数，我们等下要向下取整，就得不到10了， * 11 向下取整才能得到10
> r = Math.floor(r);
> console.log(r); // 得到一个在 [0,10] 之间的整数
> 
> ```
>
> - 分析：随机来个笑话：
>   - 笑话是个数字，有很多效果，我不知道要哪个；
>   - 随机给我来一个，随机的下标就可以；
>   - 随机的下标：随机的整数；看整数的范围：数组的长度；
>
> ```js
> var index = Math.random();  // [0,1)
> index *= list.length ; // [0,5)
> 
> // 最后一条永远拿不到，让最后一个笑话为空；
> index = Math.floor(index); // [0,4]
> 
> ```
>
> 
>
> # git
>
> ## 介绍
>
> - version
>
> - git：**做版本管理的；**
> - 版本管理：写代码，不是一次性把所有功能模块写完善的，或者写完的，代码和功能都是一点一点迭代出来，就是形成不同的版本；
> - 特点：
>   - **代码安全**：git这个工具，可以将我们写好的代码，备份到网络上面（比如：github），将来如果想要恢复，可以直接恢复；
>   - **团队开发**：在现在公司里面，绝大多数情况都是团队开发，如果没有一个可以协同的软件，人工进行代码的合并、管理是非常吃力的；
>   - **责任明确**：版本管理工具，是可以管理到出问题的代码是谁合并到一起的。
>   - **代码回滚**：之前有一个版本，是没有问题的，现在为了加新的功能，影响了原来的版本，就可以先把当前的版本进行撤销，恢复到上一个版本先进行使用。
> - **什么时候用？大家只要做个不小的项目，都要初始化一个git。**
>
> ## 安装
>
> - 官网下载对应电脑的版本：[git下载页面](https://www.git-scm.com/download/)
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/001.png)
>
> - 下载完成就会得到一个安装文件,直接双击安装，无脑下一步安装即可。
>
> ## 配置
>
> - 配置个人信息：**用于追责用**；在任务位置右键，选择 `Git Bash Here`
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/002.png)
>
> - 出现一个黑色的窗口，在窗口内输入：
>
> ```cmd
> git config --global user.email "你自己的邮箱"
> git config --global user.name "你自己的名字"
> 
> ```
>
> - 查看配置：
>
> ```
> git config --list
> 
> ```
>
> ## 使用
>
> - 其实，使用git这个黑色窗口使用命令行管理自己的代码是可以的，我们以后会学习，目前我们还是学习界面化操作；
> - 在vscode中，我们可以找到这个图标![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/004.png)
> - 点击这个图标，就可以进行源代码管理，需要选择个我们要管理代码的目录初始化：
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/005.png)
>
> - 初始化之后，会在当前要管理的文件夹下面有.git文件夹；之后当你的代码发生变量，都会在里面有提示；这个文件就是用于管理我们多个版本的文件夹；
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/006.png)
>
> - 此时如果我们想保存一下当前这个版本的代码
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/007.png)
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/008.png)
>
> - 必须输入备注信息，标识该次提交的简单的备注；
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/009.png)
>
> ## 查看
>
> - 上面只是对每次的修改做一次提交，每次提交就算是一个版本；
> - VSC下载**gitLens插件**查看每次提交的版本记录
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/010.png)
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/011.png)
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/012.png)
>
> - 多次提交版本，只能看到与上次版本的对比，如果当前最新版本有问题，我们删除了当前版本的部分代码即可；
>
> ![](E:/000-all_learning/005-itcast_videos/004-js/003-BJ-83/01-js_base/day03/01-%E8%B5%84%E6%96%99/assets/013.png)
>
> 
>
> 
>
> # 00-回顾
>
> - 字符串：字符串遇见+，使临近的数据类型变为字符串，字符串拼接；
>
> - 数字类型非常规：后台给你"1000"，如何转换为数字类型
>
>   - Number()：不是很常用；
>   - parseFloat():更为常用；
>
>   ```js
>   var num = "1000";
>   num = num*1;
>   ```
>
> - ==
>
>   - 类型相同，比下值是否相同；
>   - 类型不同，和数字进行相等的比较，把不是数字类型转换为数字类型；
>
> - ===：先决条件：先看类型
>
>   - 类型相同，比值；
>   - 类型不同，返回false;
>
> 
>
> # 01-流程控制-三个名词
>
> - 表达式：结果返回；
> - 语句、结构：为了分解你的业务场景的结构；
>
> 
>
> # 02-分支结构-if-else
>
> - 语法：如何这个条件表达式为true，就会执行它当前{}里面代码，后面的代码不会执行；
>
> ```js
>   // 
>   var sex = prompt('请输入性别');
>   // console.log(sex);
> 
> 
>   // if结构：单个条件
>   // if (sex == "男") {
> 
>   //   // sex=="男" 返回true 代码会执行
>   //   alert("这是个男人")
>   // }
> 
> 
>   // if -else：两个状态判断
> 
>   // 返回true 执行
>   // if (sex == "男") {
>   //   alert("请去男厕所")
>   // }
>   // // 这二种情况：上面返回false ,执行代码；
>   // else {
> 
>   //   // 能执行，必须是 sex == "男" 返回false;
>   //   alert("请去女厕所");
>   // }
> 
> 
> 
>   // if- else-if :多个分支情况
>   // if (sex == "男") {
>   //   alert("请去男厕所")
>   // }
>   // // 
>   // else if (sex == "女") {
>   //   alert("请去女厕所")
>   // }
>   // // 既不是男，又不是女的的情况
>   // else {
>   //   alert("你这个不男不女的家伙，没有厕所")
>   // }
> ```
>
> 
>
> # 03-分支结构-案例-求最大值
>
> - 多个状态判断：
>
> ```js
>   // 多个状态判断
>   if (a > b) {
>     alert("最大值是：" + a);
>   }
>   // a ==b
>   else if (a == b) {
>     alert("他两一样大");
>   }
>   // a < b
>   else {
>     alert("最大值是：" + b);
>   }
> ```
>
> 
>
> # 04-分支结构-switch-case
>
> - 语法：
>
> ```js
> switch （数据）{
>   case 固定值1: 
>     // 当 数据 === 固定值1 时执行的代码; 先看类型，看值；
>     
>     // 表示当前 情况结束；
>     break;
>         
>   case 固定值2: 
>     // 当数据 === 固定值2时执行的代码;
>     break;
>         
>   case 固定值3: 
>     // 当数据 === 固定值3时执行的代码;
>     break;
>   // 中间还可以写多个判断
>   
>   
>   default : 
>     // 当数据和上面的所有固定值都相等的时候执行的代码
>     break;
> }
> ```
>
> 
>
> # 05-分支结构-三元表达式
>
> - 语法：if else 简写；
>
> ```js
> // 表达式1? 表达式2:表达式3;
> 
> // 首先 要知道 表达式 会返回结果；
> // 先执行表达式1，判断其结果是true还是false，
> // 如果是true，则执行表达式2，然后将 表达式2的执行结果 作为整个三元表达式的结果，
> // 如果是false，则执行表达式3，并 表达式3的结果 作为整个三元表达式的结果
> ```
>
> 
>
> # 06-循环结构-while-语法
>
> - 语法：
>
> ```js
>   var a = 1;
> 
>   // 条件表达式：判断条件
>   while (a <= 10) {
>     console.log(a);
>     // 为了让循环退出；
>     a++;
>   }
> 
>   console.log('-----------------------------------------');
>   console.log(a);
> 
> 
>   // 第一次：1<=10,返回true,循环体执行一次；a:2;
>   // 第二次：2<=10,返回true,循环体执行一次；a:3;
>   // ...
>   // 第十次：10<=10,返回true,循环体执行一次；a:11;
>   // 第十一次：11<=10,返回false,不会执行循环体；
> ```
>
> 
>
> # 07-循环结构-while-求和及打印偶数
>
> - 语法：
>
> ```js
>   // 循环：一个一个过一次
>   // var a = 1;
>   // var sum = 0;
> 
>   // while (a <= 10) {
>   //   // 一个一个都点了次名；
>   //   // console.log(a);
> 
>   //   // 一个一个数字 往上加的过程；
>   //   sum = sum + a;
> 
>   //   a++;
>   // }
> 
>   // 当a是10：返回true
>   // sum = sum + a; 把10加上；
>   // a++    a:11
> 
>   // 当a是11 返回false
>   // 循环结束
> 
>   // 求和完毕
>   // console.log(sum);
>   // -------------------------------------------------------------
> 
>   // 需求：1-10所有偶数
>   // 分析：
>   // 1-10 循环 点名；提炼：只要见到有规律的数字变化过程：循环；
>   // 偶数条件：数字%2==0 分支结构
>   //   成立的话 true，数字才是偶数；
>   //   不成立的话 false,数字是奇数；
> 
>   var a = 1;
>   while (a <= 10) {
>     // 后台点名：数字一个的过一次；
>     // console.log(a);
> 
>     // 偶数成立的条件
>     // true : 能被2整除
>     if (a % 2 == 0) {
>       console.log(a + "是偶数");
>     }
>     // false : 不能被2除整
>     else {
>       console.log(a + "----------是奇数");
>     }
> 
>     a++;
>   }
> ```
>
> 
>
> # 08-循环结构-for
>
> - 语法：
>
> ```js
>   var he = 0;
>   // 
>   for (var a = 1; a <= 3; a++) {
>     // 每一次都要从这个循环体过一次；
>     // 每个数据都加在he上面；
>     he = he + a;
>   }
> 
>   // 这个时候，打印的he,必定是循环执行完毕；
>   console.log(he);
> 
> 
>   // 第十次：
>   // a:10
>   // a <= 10 : true
>   // 执行循环体 he = he + a; 把10加上给这个he;
>   // a++:  a--->11
> 
> 
>   // 第十一次
>   // a:11
>   // a <= 10 : false  循环结束
> ```
>
> 
>
> # 09-循环结构-案例-求偶数和
>
> # 10-循环结构-案例-打印正方形
>
> - 语法：
>
> ```js
>   // 循环：控制打印10行
>   // for (var index = 1; index <= 10; index++) {
>   //   // 执行每一次的代码；
>   //   document.write("oooooooooo");
>   //   // 换行
>   //   document.write("</br>")
>   // }
> 
> 
>   // document.write("oooooooooo");
>   // 打印 "oooooooooo"
>   // 循环：控制每行打10个；
>   // for (var index = 1; index <= 10; index++) {
>   //   document.write("o")
>   // }
> 
>   // 第一层的for循环的第一次执行，只要里面的循环没有执行完成，
>   // 第一层的for循环是不会执行第二次；
>   for (var index = 1; index <= 10; index++) {
>     // 执行每一行的代码；
>     // document.write("oooooooooo");
>     for (var jndex = 1; jndex <= 10; jndex++) {
>       document.write("o");
> 
>     }
>     // 换行
>     document.write("</br>")
>   }
> 
> ```
>
> # 11-循环结构-案例-打印金字塔
>
> ```js
>   // for for 
>   // 外面的for控制行数；告诉里面的for在哪打；
>   // 里面for循环，当被告诉是第一行的时候，打1个；
>   // 里面for循环，当被告诉是第二行的时候，打2个；
>   // ...
>   // 里面for循环，当被告诉是第十行的时候，打10个；
> 
>   for (var index = 1; index <= 10; index++) {
>     // console.log(index);
> 
>     // 外面的for第一次进来的时候。index:1;
>     // 外面的for第五次进来的时候。index5;
>     // 外面的for第十次进来的时候。index:10;
> 
>     // 打几个；
>     for (let jndex = 1; jndex <= index; jndex++) {
>       document.write("o");
>     }
> 
>     // 换行；
>     document.write("</br>");
>   }
> 
> ```
>
> 
>
> # 12-循环结构-do-while循环及小结
>
> - while、do-while 循环不易看出循环的次数，一般用于**未知次数的循环**
> - for循环明显看出循环的次数，一般用于已知次数的循环；**使用最多是for；**
> - while、for循环可能一次循环都不会执行
> - do-while 循环至少执行一次；
>
> 
>
> # 13-循环结构-break和continue
>
> - break：**直接退出后面所有循环**；后面所有的循环都不会执行；
> - continue：**跳过当前**循环；后面的循环还会执行；
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 
